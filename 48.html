<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>è›‹ç™½å®šé‡ä¸ç¨€é‡ŠåŠ©æ‰‹ - ç²¾åº¦ä¼˜åŒ–ç‰ˆ</title>
    <style>
        :root { --primary: #007bff; --success: #67c23a; --warning: #e6a23c; --danger: #f56c6c; --bg-blue: #ebf5ff; }
        body { font-family: 'PingFang SC', sans-serif; background: #f0f2f5; padding: 20px; color: #333; line-height: 1.5; }
        .card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); max-width: 1550px; margin: 0 auto 25px; }
        .section-title { border-left: 6px solid var(--primary); padding-left: 15px; margin-bottom: 20px; font-size: 1.3rem; font-weight: bold; color: var(--primary); display: flex; justify-content: space-between; align-items: center; }
        .controls { display: flex; gap: 12px; align-items: center; background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; flex-wrap: wrap; border: 1px solid #e9ecef; }
        .input-group { display: flex; align-items: center; gap: 5px; font-size: 14px; position: relative; }
        input, select { border: 1px solid #dcdfe6; padding: 7px; border-radius: 4px; outline: none; transition: 0.3s; text-align: center; }
        input:focus { border-color: var(--primary); box-shadow: 0 0 5px rgba(0,123,255,0.2); }
        table { width: 100%; border-collapse: collapse; margin-bottom: 15px; table-layout: fixed; }
        th, td { border: 1px solid #dee2e6; padding: 10px; text-align: center; font-size: 13px; }
        th { background: #f1f3f5; color: #495057; cursor: pointer; user-select: none; }
        .avg-cell { background: #f8f9fa; font-weight: bold; }
        .res-cell { background: #e7f3ff; color: #0056b3; font-weight: bold; }
        .btn { padding: 9px 18px; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: 500; transition: 0.2s; display: inline-flex; align-items: center; gap: 5px; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--danger); color: white; }
        .lock-btn { cursor: pointer; font-size: 12px; padding: 4px 8px; border-radius: 4px; background: #fff; border: 1px solid #dcdfe6; }
        .lock-btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .precision-toggle { display: flex; background: #eee; border-radius: 4px; padding: 2px; }
        .precision-toggle span { padding: 4px 10px; cursor: pointer; font-size: 12px; border-radius: 3px; }
        .precision-toggle span.active { background: white; color: var(--primary); box-shadow: 0 1px 4px rgba(0,0,0,0.1); }
        .formula-box { background: #eef6ff; border: 1px solid #b8daff; padding: 15px; border-radius: 8px; margin-top: 10px; }
        .toast { position: fixed; top: 30px; left: 50%; transform: translateX(-50%); background: #28a745; color: white; padding: 12px 35px; border-radius: 50px; z-index: 9999; display: none; }
        .history-scroll-area { max-height: 120px; overflow-y: auto; border: 1px solid #ddd; background: #fff; margin-top: 10px; border-radius: 4px; }
        .history-item { padding: 8px 12px; font-size: 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .history-item:hover { background: #f0f7ff; }
        .edit-conc { background: #fff7e6; border-color: #ffd591; font-weight: bold; }
        .lowest-tag { background: var(--danger); color: white; padding: 1px 4px; border-radius: 3px; font-size: 10px; margin-left: 2px; }
        .summary { margin-top: 10px; padding: 15px; background: #f0f9eb; border-radius: 8px; display: flex; gap: 40px; border: 1px solid #c2e7b0; font-size: 14px; }
        .btn-mini { padding: 2px 6px; font-size: 10px; }
        .del-hist-btn { color: var(--danger); border: 1px solid var(--danger); background: none; border-radius: 3px; cursor: pointer; padding: 0 5px; margin-left: 10px; }
    </style>
</head>
<body>

<div id="app">
    <div id="toast" class="toast">âœ“ {{ toastMsg }}</div>

    <div class="card">
        <div class="section-title">ç¬¬ä¸€éƒ¨åˆ†ï¼šæ ‡å‡†æ›²çº¿æ‹Ÿåˆï¼ˆå»ºæ¨¡ï¼‰</div>
        <div class="controls">
            <span>æ¢¯åº¦æ•°:</span><input type="number" v-model.number="stdRowCount" @change="adjustStdTable">
            <span>é‡å¤æ•°:</span><input type="number" v-model.number="stdColCount" @change="adjustStdTable">
            <span>æ‹Ÿåˆç±»å‹:</span>
            <select v-model="fitType" @change="doStdFit">
                <option :value="1">çº¿æ€§æ‹Ÿåˆ</option><option :value="2">äºŒæ¬¡å¤šé¡¹å¼</option><option :value="3">ä¸‰æ¬¡å¤šé¡¹å¼</option><option :value="4">å››æ¬¡å¤šé¡¹å¼</option>
            </select>
            <button class="btn btn-danger" @click="resetStd">æ¸…ç©ºæ•°æ®</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th width="140">æ ‡å‡†æµ“åº¦(ug/ml)</th>
                    <th v-for="c in stdColCount">å¸å…‰åº¦ {{c}}</th>
                    <th>å¹³å‡å€¼</th><th>çŸ«æ­£OD</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(row, rIdx) in stdData">
                    <td><input type="text" style="width:90%" v-model="row.conc" @input="doStdFit"></td>
                    <td v-for="c in stdColCount">
                        <input type="text" style="width:90%" v-model="row.abs[c-1]" @input="doStdFit" @paste="handlePaste($event, stdData, rIdx, c-1, 'std')">
                    </td>
                    <td class="avg-cell">{{ fmt(row.avg, 4) }}</td>
                    <td class="res-cell" style="background: #f0fff0;">{{ fmt(row.adj, 4) }}</td>
                </tr>
            </tbody>
        </table>
        <div class="formula-box">
            <strong>æ‹Ÿåˆæ–¹ç¨‹ï¼š</strong> <code style="font-size:16px; color:var(--primary);">{{ stdResult.formula || 'ç­‰å¾…è¾“å…¥æœ‰æ•ˆæ•°æ®...' }}</code>
            <span v-if="stdResult.r2" style="margin-left:25px; color:#fd7e14">RÂ² = {{ stdResult.r2 }}</span>
            <button class="btn btn-primary" style="float:right" @click="saveFormula(stdResult)">ä¿å­˜æˆæœ</button>
        </div>
    </div>

    <div class="card">
        <div class="section-title">
            <span>ç¬¬äºŒéƒ¨åˆ†ï¼šæ ·å“æµ“åº¦è®¡ç®—</span>
            <button class="btn btn-success" @click="exportP2Excel">ğŸ“¥ å¯¼å‡ºè®¡ç®—è¡¨</button>
        </div>
        <div class="controls">
            <span>æ ·æœ¬æ•°:</span><input type="number" v-model.number="smpRowCount" @change="adjustSmpTable">
            <span>é‡å¤æ•°:</span><input type="number" v-model.number="smpColCount" @change="adjustSmpTable">
            <span>æ‰¹é‡å€æ•°:</span><input type="number" v-model.number="globalRatio" @input="applyGlobalRatio">
            <span>å…¬å¼æ¥æº:</span>
            <select v-model="smpFormulaSource" @change="applyFormulaSource">
                <option value="current">å®æ—¶åŒæ­¥ä¸Šæ–¹æ‹Ÿåˆ</option>
                <option value="manual">ä»å†å²åº“æ‰‹åŠ¨æŒ‘é€‰</option>
            </select>
            <button class="btn btn-warning btn-mini" @click="customFormula">æ‰‹åŠ¨è¾“å…¥å…¬å¼</button>
        </div>
        <div v-if="smpFormulaSource==='manual'" class="history-scroll-area">
            <div class="history-item" v-for="(f, i) in savedFormulas">
                <div @click="useLibraryFormula(f)" style="flex:1">
                    <span>è®°å½•#{{savedFormulas.length - i}}: {{ f.formula }}</span>
                    <span style="color:#666; margin-left:15px">RÂ²={{f.r2}}</span>
                </div>
                <button class="del-hist-btn" @click.stop="deleteFormula(i)">åˆ é™¤</button>
            </div>
        </div>
        <table>
            <thead>
                <tr>
                    <th width="140">æ ·æœ¬ç¼–å·</th>
                    <th v-for="c in smpColCount">OD å€¼ {{c}}</th>
                    <th>å¹³å‡ OD</th><th>çŸ«æ­£ OD</th><th width="80">å€æ•°</th>
                    <th>æµ“åº¦(ug/ml)</th><th>åŸæ¶²(ug/ml)</th><th>åŸæ¶²(ug/ul)</th>
                </tr>
            </thead>
            <tbody>
                <tr style="background:#fffaf0">
                    <td>
                        <strong>ç©ºç™½èƒŒæ™¯</strong>
                        <button class="btn-mini" style="margin-left:5px" @click="keepBlankOD">ä¿å­˜ä¸ºé»˜è®¤</button>
                    </td>
                    <td v-for="c in smpColCount"><input type="text" style="width:90%" v-model="smpBlank.abs[c-1]" @input="doSmpCalc"></td>
                    <td class="avg-cell">{{ fmt(smpBlank.avg, 4) }}</td>
                    <td colspan="5"></td>
                </tr>
                <tr v-for="(row, rIdx) in smpData">
                    <td><input type="text" style="width:90%" v-model="row.id" @paste="handlePaste($event, smpData, rIdx, -1, 'id')"></td>
                    <td v-for="c in smpColCount">
                        <input type="text" style="width:90%" v-model="row.abs[c-1]" @input="doSmpCalc" @paste="handlePaste($event, smpData, rIdx, c-1, 'smp')">
                    </td>
                    <td class="avg-cell">{{ fmt(row.avg, 4) }}</td>
                    <td class="avg-cell" style="color:var(--primary)">{{ fmt(row.adj, 4) }}</td>
                    <td><input type="number" style="width:80%" v-model.number="row.ratio" @input="doSmpCalc"></td>
                    <td class="res-cell">{{ fmt(row.concDiluted, 4) }}</td>
                    <td class="res-cell" style="background:#fffcf0">{{ fmt(row.concRawML, 4) }}</td>
                    <td class="res-cell" style="background:#f0faff">{{ fmt(row.concRawUL, 4) }}</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="card" style="border-top: 4px solid var(--success);">
        <div class="section-title">
            <span>ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ ·æœ¬ç¨€é‡Šä¸å˜æ€§é…æ–¹</span>
            <div style="display: flex; gap: 10px; align-items: center;">
                <div class="precision-toggle">
                    <span :class="{active: precision === 1}" @click="precision = 1">ä¿ç•™1ä½</span>
                    <span :class="{active: precision === 2}" @click="precision = 2">ä¿ç•™2ä½</span>
                </div>
                <button class="btn btn-success" @click="exportP3Excel">ğŸ“¥ å¯¼å‡ºé…æ–¹</button>
            </div>
        </div>

        <div class="controls" style="background: #f0f9eb;">
            <span>æ•°æ®æº:</span>
            <select v-model="p3Source" @change="handleP3SourceChange">
                <option value="manual">æ‰‹åŠ¨è¾“å…¥/å¢åŠ </option>
                <option value="p2">åŒæ­¥ç¬¬äºŒéƒ¨åˆ†ç»“æœ</option>
            </select>
            <div v-if="p3Source==='manual'" class="input-group">
                <span>æ ·æœ¬æ•°:</span>
                <input type="number" v-model.number="p3SampleCount" @change="adjustP3Count" style="width:60px">
            </div>
            <div style="width: 1px; height: 20px; background: #ccc; margin: 0 5px;"></div>
            <div class="input-group">
                <span @click="lock = 'M'" class="lock-btn" :class="{active: lock === 'M'}">{{ lock === 'M' ? 'ğŸ”’ å›ºå®šè´¨é‡' : 'ğŸ”“ è›‹ç™½è´¨é‡' }}</span>
                <input type="number" v-model.number="gM" @input="syncP3('M')">
            </div>
            <div class="input-group">
                <span @click="lock = 'V'" class="lock-btn" :class="{active: lock === 'V'}">{{ lock === 'V' ? 'ğŸ”’ å›ºå®šä½“ç§¯' : 'ğŸ”“ æ€»ä½“ç§¯' }}</span>
                <input type="number" v-model.number="gV" @input="syncP3('V')">
            </div>
            <div class="input-group">
                <span @click="lock = 'C'" class="lock-btn" :class="{active: lock === 'C'}">{{ lock === 'C' ? 'ğŸ”’ å›ºå®šæµ“åº¦' : 'ğŸ”“ æœ€ç»ˆæµ“åº¦' }}</span>
                <input type="number" v-model.number="gC" @input="syncP3('C')">
            </div>
            <button class="btn btn-warning" @click="matchLowest">æ ¹æ®æœ€ä½æµ“åº¦è‡ªåŠ¨å¯¹é½ (RIPA=0)</button>
        </div>

        <table>
            <thead>
                <tr>
                    <th @click="sortP3('id')">æ ·å“ç¼–å· â†•</th>
                    <th @click="sortP3('oC')">åŸæ¶²æµ“åº¦(Î¼g/Î¼l) â†•</th>
                    <th @click="sortP3('tM')">è›‹ç™½è´¨é‡(Î¼g) â†•</th>
                    <th>è›‹ç™½ä½“ç§¯(Î¼l)</th>
                    <th @click="sortP3('vR')">RIPA(Î¼l) â†•</th>
                    <th>5Ã— Buffer(Î¼l)</th>
                    <th @click="sortP3('vT')">æ€»ä½“ç§¯(Î¼l) â†•</th>
                    <th>å®é™…æµ“åº¦</th>
                    <th width="60">æ“ä½œ</th>
                </tr>
            </thead>
            <tbody>
                <tr v-for="(s, i) in p3List" :key="i">
                    <td><input type="text" style="width:90%" v-model="s.id" :disabled="p3Source==='p2'" @paste="handleP3Paste($event, i, 'id')"></td>
                    <td v-if="p3Source==='p2'" style="background:#f9f9f9; font-weight:bold">{{ fmt(s.oC, 4) }} <span v-if="s.isMin" class="lowest-tag">Min</span></td>
                    <td v-else>
                        <input type="number" class="edit-conc" style="width:70%" v-model.number="s.oC" @input="p3RowCalc(i)" @paste="handleP3Paste($event, i, 'conc')">
                        <span v-if="s.isMin" class="lowest-tag">Min</span>
                    </td>
                    <td><input type="number" style="width:90%" v-model.number="s.tM" @input="p3RowCalc(i, 'M')"></td>
                    <td style="background:#f9f9f9">{{ fmt(s.vP, precision) }}</td>
                    <td :style="{color: s.vR < 0 ? 'red' : 'inherit', fontWeight: s.vR < 0 ? 'bold' : 'normal'}">
                        {{ fmt(s.vR, precision) }}
                    </td>
                    <td>{{ fmt(s.vB, precision) }}</td>
                    <td><input type="number" style="width:90%" v-model.number="s.vT" @input="p3RowCalc(i, 'V')"></td>
                    <td style="color:var(--primary); font-weight:bold">{{ fmt(s.fC, 4) }}</td>
                    <td><button class="btn btn-danger btn-mini" @click="deleteP3Row(i)">åˆ é™¤</button></td>
                </tr>
            </tbody>
        </table>

        <div class="summary">
            <strong>ğŸ§ª è¯•å‰‚å‡†å¤‡ç»Ÿè®¡ï¼š</strong>
            <span>RIPA è¡¥æ¶²æ€»éœ€æ±‚: <b>{{ totalR }}</b> Î¼l</span>
            <span>5Ã— Loading Buffer æ€»éœ€æ±‚: <b>{{ totalB }}</b> Î¼l</span>
            <span style="font-size: 12px; color: #666; margin-left: auto;">* RIPAå°äº0æ—¶ç»Ÿè®¡ä¸è®¡å…¥è´Ÿå€¼</span>
        </div>
    </div>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
const { createApp } = Vue;
createApp({
    data() {
        return {
            stdRowCount: 8, stdColCount: 3, fitType: 3, stdData: [],
            stdResult: { formula: '', coeffs: [], r2: '' },
            savedFormulas: JSON.parse(localStorage.getItem('protein_lib_v7') || '[]'),
            smpRowCount: 5, smpColCount: 3, smpFormulaSource: 'current',
            activeCoeffs: [], activeFormulaStr: '', globalRatio: 10,
            smpBlank: { abs: JSON.parse(localStorage.getItem('p2_blank_od_keep') || '[""]') }, 
            smpData: [],
            p3Source: 'manual', p3SampleCount: 6, lock: 'M', precision: 2,
            gM: 200, gV: 100, gC: 2, p3List: [], sortKey: '', sortOrder: 1,
            toastMsg: 'æ“ä½œæˆåŠŸ'
        }
    },
    computed: {
        totalR() { return this.p3List.reduce((a, b) => a + Math.max(0, b.vR), 0).toFixed(this.precision); },
        totalB() { return this.p3List.reduce((a, b) => a + b.vB, 0).toFixed(this.precision); }
    },
    mounted() { 
        this.initTables(); 
        this.adjustP3Count();
        this.doSmpCalc();
    },
    methods: {
        fmt(v, p) { return (v === undefined || v === null || isNaN(v)) ? (0).toFixed(p) : parseFloat(v).toFixed(p); },
        initTables() {
            const def = [0, 25, 125, 250, 500, 750, 1500, 2000];
            this.stdData = Array.from({length:this.stdRowCount}, (_,i)=>({ conc:def[i]||'', abs:Array(this.stdColCount).fill(''), avg:0, adj:0 }));
            if(this.smpBlank.abs.length < this.smpColCount) this.smpBlank.abs = Array(this.smpColCount).fill('');
            this.smpData = Array.from({length:this.smpRowCount}, ()=>({ id:'', abs:Array(this.smpColCount).fill(''), ratio:1, avg:0, adj:0, concDiluted:0, concRawML:0, concRawUL:0 }));
        },
        doStdFit() {
            this.stdData.forEach(r => {
                let v = r.abs.map(x => parseFloat(x)).filter(x => !isNaN(x));
                r.avg = v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : 0;
            });
            let bRow = this.stdData.find(r => parseFloat(r.conc) === 0);
            let b = bRow ? bRow.avg : 0;
            this.stdData.forEach(r => r.adj = Math.max(0, r.avg - b));
            let pts = this.stdData.filter(r => r.conc !== '' && !isNaN(parseFloat(r.conc)) && r.avg !== 0)
                                 .map(r => ({x: r.adj, y: parseFloat(r.conc)}));
            if(pts.length > this.fitType) {
                const cfs = this.polyFit(pts.map(p=>p.x), pts.map(p=>p.y), this.fitType);
                if (cfs) {
                    this.stdResult = { coeffs:cfs, formula:this.formatFormula(cfs), r2:this.calcR2(pts.map(p=>p.x), pts.map(p=>p.y), cfs).toFixed(6) };
                    if(this.smpFormulaSource === 'current') { this.activeFormulaStr = this.stdResult.formula; this.activeCoeffs = cfs; }
                    this.doSmpCalc();
                }
            }
        },
        doSmpCalc() {
            let bv = this.smpBlank.abs.map(x => parseFloat(x)).filter(x => !isNaN(x));
            this.smpBlank.avg = bv.length ? (bv.reduce((a,b)=>a+b,0)/bv.length) : 0;
            this.smpData.forEach(r => {
                let v = r.abs.map(x => parseFloat(x)).filter(x => !isNaN(x));
                r.avg = v.length ? (v.reduce((a,b)=>a+b,0)/v.length) : 0;
                r.adj = Math.max(0, r.avg - this.smpBlank.avg);
                if(this.activeCoeffs && this.activeCoeffs.length) {
                    let y = 0;
                    this.activeCoeffs.forEach((c, i) => y += c * Math.pow(r.adj, i));
                    r.concDiluted = Math.max(0, y);
                    r.concRawML = r.concDiluted * (parseFloat(r.ratio) || 1);
                    r.concRawUL = r.concRawML / 1000;
                }
            });
            if(this.p3Source === 'p2') this.syncFromP2();
        },
        handleP3Paste(e, rIdx, mode) {
            if (this.p3Source === 'p2') return;
            e.preventDefault();
            let text = e.clipboardData.getData('text');
            let lines = text.split(/\r?\n/).filter(s => s.trim() !== '');
            lines.forEach((line, i) => {
                let targetIdx = rIdx + i;
                if (targetIdx >= this.p3List.length) {
                    this.p3List.push({ id: 'S'+(targetIdx+1), oC: 0, tM: this.gM, vP: 0, vB: 0, vR: 0, vT: this.gV, fC: 0, isMin: false });
                    this.p3SampleCount = this.p3List.length;
                }
                let row = this.p3List[targetIdx];
                let cells = line.split('\t');
                if (mode === 'id') {
                    row.id = cells[0].trim();
                    if (cells.length > 1) row.oC = parseFloat(cells[1]) || 0;
                } else if (mode === 'conc') {
                    row.oC = parseFloat(cells[0]) || 0;
                }
                this.p3Core(row);
            });
            this.markMin();
            this.showToast("å·²æˆåŠŸæ‰¹é‡ç²˜è´´æ•°æ®");
        },
        keepBlankOD() {
            localStorage.setItem('p2_blank_od_keep', JSON.stringify(this.smpBlank.abs));
            this.showToast("ç©ºç™½ OD å·²ä¿å­˜ä¸ºé»˜è®¤å€¼");
        },
        deleteFormula(index) {
            if(confirm("ç¡®å®šåˆ é™¤è¯¥æ¡å†å²å…¬å¼å—ï¼Ÿ")) {
                this.savedFormulas.splice(index, 1);
                localStorage.setItem('protein_lib_v7', JSON.stringify(this.savedFormulas));
            }
        },
        customFormula() {
            const input = prompt("è¯·è¾“å…¥æ‹Ÿåˆå…¬å¼ (ä¾‹å¦‚: y = 1500x + 10):");
            if (!input) return;
            try {
                const regex = /(-?\d*\.?\d+)x\^?(\d?)|(-?\d*\.?\d+)/g;
                let match, cfs = [0, 0, 0, 0, 0];
                while ((match = regex.exec(input.replace(/\s+/g, ''))) !== null) {
                    if (match[3]) cfs[0] = parseFloat(match[3]);
                    else {
                        let p = parseInt(match[2] || "1");
                        cfs[p] = parseFloat(match[1] === "-" ? "-1" : (match[1] === "" ? "1" : match[1]));
                    }
                }
                const newFit = { formula: input, coeffs: cfs.filter((v,i)=>i<=4), r2: "Manual" };
                this.saveFormula(newFit);
                this.useLibraryFormula(newFit);
            } catch (e) { alert("å…¬å¼è§£æå¤±è´¥ã€‚"); }
        },
        exportP2Excel() {
            const cols = this.smpColCount;
            let csv = "\uFEFFç¬¬äºŒéƒ¨åˆ†ï¼šæ ·å“æµ“åº¦è®¡ç®—ç»“æœ\n";
            csv += `æ‹Ÿåˆå…¬å¼,${this.activeFormulaStr},R2,${this.stdResult.r2 || 'N/A'}\n\n`;
            csv += "æ ·æœ¬ç¼–å·,";
            for(let i=1; i<=cols; i++) csv += `å¸å…‰åº¦${i},`;
            csv += "å¹³å‡OD,çŸ«æ­£OD,å€æ•°,æµ“åº¦(ug/ml),åŸæ¶²æµ“åº¦(ug/ml),åŸæ¶²(ug/ul)\n";
            csv += "ç©ºç™½èƒŒæ™¯,";
            this.smpBlank.abs.forEach(v => csv += `${v},`);
            const avgFormulaBlank = `=AVERAGE(${this.getColChar(1)}5:${this.getColChar(cols)}5)`;
            csv += `${avgFormulaBlank},,,,,\n`;
            this.smpData.forEach((r, idx) => {
                const curRow = idx + 6;
                csv += `${r.id || 'S'+(idx+1)},`;
                r.abs.forEach(v => csv += `${v},`);
                const avgF = `=AVERAGE(${this.getColChar(1)}${curRow}:${this.getColChar(cols)}${curRow})`;
                const adjF = `=${this.getColChar(cols+1)}${curRow}-$${this.getColChar(cols+1)}$5`;
                let concExcel = "=";
                this.activeCoeffs.forEach((c, i) => {
                    if(c === 0) return;
                    concExcel += `${c}*POWER(${this.getColChar(cols+2)}${curRow},${i})+`;
                });
                concExcel = concExcel.slice(0, -1);
                csv += `${avgF},${adjF},${r.ratio},${concExcel},=${this.getColChar(cols+4)}${curRow}*${this.getColChar(cols+3)}${curRow},=${this.getColChar(cols+5)}${curRow}/1000\n`;
            });
            this.downloadCSV(csv, `æµ“åº¦è®¡ç®—è¡¨_${new Date().getTime()}.csv`);
        },
        exportP3Excel() {
            let csv = "\uFEFFç¬¬ä¸‰éƒ¨åˆ†ï¼šç¨€é‡Šé…æ–¹ï¼ˆå·²åº”ç”¨ç½‘é¡µç²¾åº¦è®¾ç½®ï¼‰\n";
            // å¯¼å‡ºè¡¨å¤´ä¹Ÿç›¸åº”äº’æ¢ï¼šRIPAåœ¨å‰ï¼Œ5x Bufferåœ¨å
            csv += "æ ·å“ç¼–å·,åŸæ¶²æµ“åº¦(ug/ul),ç›®æ ‡è´¨é‡(ug),è›‹ç™½ä½“ç§¯(ul),RIPA(ul),5x Buffer(ul),æ€»ä½“ç§¯(ul),å®é™…æµ“åº¦(ug/ul)\n";
            const p = this.precision;
            this.p3List.forEach((s) => {
                // å¯¼å‡ºæ•°æ®ä¹Ÿäº’æ¢ä½ç½®
                csv += `${s.id},${s.oC.toFixed(4)},${s.tM.toFixed(p)},${s.vP.toFixed(p)},${s.vR.toFixed(p)},${s.vB.toFixed(p)},${s.vT.toFixed(p)},${s.fC.toFixed(4)}\n`;
            });
            this.downloadCSV(csv, `è›‹ç™½ç¨€é‡Šé…æ–¹_${new Date().getTime()}.csv`);
        },
        getColChar(n) { return String.fromCharCode(65 + n); },
        downloadCSV(csv, name) {
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = name;
            link.click();
        },
        showToast(msg) {
            this.toastMsg = msg;
            const t = document.getElementById('toast'); t.style.display='block'; 
            setTimeout(()=>t.style.display='none', 2000); 
        },
        handleP3SourceChange() { this.p3Source === 'p2' ? this.syncFromP2() : this.adjustP3Count(); },
        syncFromP2() {
            this.p3List = this.smpData.map(r => ({
                id: r.id || 'Unnamed', oC: r.concRawUL || 0, tM: this.gM, vT: this.gV, vP: 0, vB: 0, vR: 0, fC: 0, isMin: false
            }));
            this.updateAllP3();
        },
        adjustP3Count() {
            if(this.p3Source === 'p2') return;
            const current = this.p3List.length;
            if (this.p3SampleCount > current) {
                for(let i=current+1; i<=this.p3SampleCount; i++) 
                    this.p3List.push({ id: 'S'+i, oC: 0, tM: this.gM, vP: 0, vB: 0, vR: 0, vT: this.gV, fC: 0, isMin: false });
            } else this.p3List = this.p3List.slice(0, this.p3SampleCount);
            this.updateAllP3();
        },
        deleteP3Row(index) {
            this.p3List.splice(index, 1);
            if(this.p3Source === 'manual') this.p3SampleCount = this.p3List.length;
            this.markMin();
        },
        syncP3(caller) {
            if (this.lock === 'M') {
                if (caller === 'V' && this.gV) this.gC = this.gM / this.gV;
                if (caller === 'C' && this.gC) this.gV = this.gM / this.gC;
            } else if (this.lock === 'V') {
                if (caller === 'M' && this.gM) this.gC = this.gM / this.gV;
                if (caller === 'C' && this.gC) this.gM = this.gC * this.gV;
            } else if (this.lock === 'C') {
                if (caller === 'M' && this.gM) this.gV = this.gM / this.gC;
                if (caller === 'V' && this.gV) this.gM = this.gC * this.gV;
            }
            this.updateAllP3();
        },
        updateAllP3() { this.p3List.forEach(s => { if(this.gM) s.tM = this.gM; if(this.gV) s.vT = this.gV; this.p3Core(s); }); this.markMin(); },
        p3RowCalc(i, caller) {
            const s = this.p3List[i];
            if ((caller === 'M' || caller === 'V') && s.vT) s.fC = s.tM / s.vT;
            this.p3Core(s); this.markMin();
        },
        p3Core(s) { if(s.oC > 0) { s.vP = s.tM / s.oC; s.vB = s.vT / 5; s.vR = s.vT - s.vP - s.vB; s.fC = s.tM / s.vT; } },
        markMin() {
            const valid = this.p3List.filter(s => s.oC > 0);
            if(!valid.length) return;
            const minVal = Math.min(...valid.map(s => s.oC));
            this.p3List.forEach(s => s.isMin = (s.oC > 0 && Math.abs(s.oC - minVal) < 0.00001));
        },
        matchLowest() {
            const valid = this.p3List.filter(s => s.oC > 0);
            if (!valid.length) return;
            const minS = valid.reduce((prev, curr) => (prev.oC < curr.oC) ? prev : curr);
            this.gV = (minS.tM / minS.oC) / 0.8;
            this.syncP3('V');
        },
        sortP3(key) {
            if (this.sortKey === key) this.sortOrder *= -1;
            else { this.sortKey = key; this.sortOrder = 1; }
            this.p3List.sort((a, b) => (key === 'id') ? a.id.toString().localeCompare(b.id.toString()) * this.sortOrder : (a[key] - b[key]) * this.sortOrder);
        },
        polyFit(x, y, deg) {
            let s = deg+1; let m = Array.from({length:s},()=>Array(s+1).fill(0));
            for(let i=0;i<s;i++){
                for(let j=0;j<s;j++){ let sx=0; x.forEach(xv=>sx+=Math.pow(xv,i+j)); m[i][j]=sx; }
                let sy=0; x.forEach((xv,k)=>sy+=y[k]*Math.pow(xv,i)); m[i][s]=sy;
            }
            return this.gauss(m);
        },
        gauss(m) {
            let n=m.length; for(let i=0;i<n;i++){
                let p=i; for(let j=i+1;j<n;j++) if(Math.abs(m[j][i])>Math.abs(m[p][i])) p=j;
                [m[i],m[p]]=[m[p],m[i]]; if(Math.abs(m[i][i]) < 1e-12) return null;
                for(let j=i+1;j<n;j++){ let c=-m[j][i]/m[i][i]; for(let k=i;k<=n;k++) m[j][k]+=c*m[i][k]; }
            }
            let res=Array(n).fill(0); for(let i=n-1;i>=0;i--){
                res[i]=m[i][n]/m[i][i]; for(let j=i-1;j>=0;j--) m[j][n]-=m[j][i]*res[i];
            } return res;
        },
        formatFormula(c) {
            let s = "y = ";
            for(let i=c.length-1; i>=0; i--){
                let v = parseFloat(c[i]); if(isNaN(v)) continue;
                let vStr = Math.abs(v).toFixed(6);
                if(i===0) s += (v>=0?" + ":" - ") + vStr;
                else s += (i===c.length-1?(v<0?"-":""): (v>=0?" + ":" - ")) + vStr + (i===1?"x":"x^"+i);
            } return s;
        },
        calcR2(x,y,cfs){
            let m=y.reduce((a,b)=>a+b,0)/y.length; let res=0,tot=0;
            x.forEach((xv,i)=>{ let p=0; cfs.forEach((c,j)=>p+=c*Math.pow(xv,j)); res+=Math.pow(y[i]-p,2); tot+=Math.pow(y[i]-m,2); });
            return tot===0?1:1-(res/tot);
        },
        handlePaste(e, data, rIdx, cIdx, mode) {
            e.preventDefault();
            let text = e.clipboardData.getData('text');
            text.split(/\n/).filter(s=>s.trim()!=='').forEach((line, i) => {
                let r = data[rIdx+i]; if(!r) return;
                let cells = line.split('\t');
                cells.forEach((val, j) => {
                    if(mode === 'id' && j === 0) r.id = val.trim();
                    else if(cIdx+j < r.abs.length) r.abs[cIdx+j] = val.trim();
                });
            });
            mode === 'std' ? this.doStdFit() : this.doSmpCalc();
        },
        saveFormula(res) { 
            this.savedFormulas.unshift(JSON.parse(JSON.stringify(res))); 
            localStorage.setItem('protein_lib_v7', JSON.stringify(this.savedFormulas));
            this.showToast("å…¬å¼å·²ä¿å­˜è‡³å†å²åº“");
        },
        adjustStdTable() { this.stdData = this.maintain(this.stdData, this.stdRowCount, this.stdColCount); this.doStdFit(); },
        adjustSmpTable() { this.smpData = this.maintain(this.smpData, this.smpRowCount, this.smpColCount); this.doSmpCalc(); },
        maintain(old, rows, cols) {
            return Array.from({length:rows}, (_, i) => {
                let r = old[i] || { id:'', abs:Array(cols).fill(''), ratio:1 };
                r.abs = Array.from({length:cols}, (_, j) => r.abs[j] || '');
                return r;
            });
        },
        resetStd() { if(confirm("æ¸…ç©ºï¼Ÿ")) this.initTables(); },
        applyGlobalRatio() { this.smpData.forEach(r => r.ratio = this.globalRatio); this.doSmpCalc(); },
        useLibraryFormula(f) { this.activeFormulaStr=f.formula; this.activeCoeffs=f.coeffs; this.smpFormulaSource='manual'; this.doSmpCalc(); },
        applyFormulaSource() { if(this.smpFormulaSource === 'current') this.doStdFit(); }
    }
}).mount('#app');
</script>
</body>
</html>
